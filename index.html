<!DOCTYPE html>
<html>
<head>
    <meta charset='utf-8'>
    <title>Алгоритмы Сортировки</title>
    <meta name='viewport' content='width=device-width, initial-scale=1'>
    <link rel='stylesheet' type='text/css' media='screen' href='main.css'>
    <script src='https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.2.0/chart.min.js'></script>
    <script src='main.js'></script>

</head>
<body>

    <header>
        <span id="arr">[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]</span>
        <script>
        </script>
        <span id="alg">Алгоритмы<br/>Сортировки</span>
    </header>

    <div class="topmenu">
        <table>
            <tr>
                <td><a href="#SortIn">Сортировка выбором</a></td>
                <td><a href="#BubleS">Пузырьковая сортировка</a></td>
                <td><a href="#InsertS">Сортировка вставками</a></td>
                <td><a href="#ShellS">Сортировка Шелла</a></td>
                <td><a href="#MergeS">Сортировка слиянием</a></td>
                <td style="border: none;"><a href="#CounS">Сортировка подсчетом</a></td>
            </tr>
        </table>
    </div>

    <div class="shead" id="SortIn">

        <h1 class="title">Сортировка выбором</h1>

        <span class="dis">
            Возможно, самый простой в реализации алгоритм сортировки. Как и в большинстве других подобных алгоритмов, в его основе лежит операция сравнения.
            Сравнивая каждый элемент с каждым, и в случае необходимости производя обмен, метод приводит последовательность к необходимому упорядоченному виду.
            В некоторых ситуациях стоит предпочесть ее наиболее сложным и совершенным методам, но в большинстве случаев данный алгоритм уступает в эффективности последним.
            Идея алгоритма очень проста. Пусть имеется массив A размером N, тогда сортировка выбором сводится к следующему:
            берем первый элемент входного массива, здесь i – номер элемента, для первого i равен 1
            находим минимальный (максимальный) элемент последовательности и запоминаем его номер в переменную key
            если номер первого элемента и номер найденного элемента не совпадают, т. е. если key = 1, тогда два этих элемента обмениваются значениями, иначе никаких манипуляций не происходит
            увеличиваем i на 1 и продолжаем сортировку оставшейся части массива, а именно с элемента с номером 2 по N, так как 1 элемент входного уже занимает свою позицию
            С каждым последующим шагом размер подмассива, с которым работает алгоритм, уменьшается на 1, но на способ сортировки это не влияет, он одинаков для каждого шага.
        </span>
            
        <canvas id="SelectionChart"></canvas>
        <form class="buttons">
            <input type="text" class="Count" id="Selco" value="0" width="150" disabled>
            <input type="button" class="Brand" value="Перемешать" width="150" onclick="ShuffleSS()">
            <input type="button" class="Iter" value="Шаг" width="150" onclick="SortSSO()">
            <input type="button" class="Sort" value="Сортировать" width="150" onclick="SortSS()">
        </form>

        <button class="accordion">Код</button>
        <div class="panel">
          <p>
            function selectionSort(inputArr) {<br>
                &emsp;let n = inputArr.length;<br>
                &emsp;for(let i = 0; i < n; i++) {<br>
                	&emsp;let min = i;<br>
                	&emsp;for(let j = i; j < n; j++) {<br>
                        &emsp;	&emsp;if(inputArr[j] < inputArr[min]) {<br>
                            &emsp;	&emsp;	&emsp;min=j;}<br>
                            &emsp;&emsp;}<br>
                        	&emsp;	&emsp;if (min != i) {<br>
                            	&emsp;	&emsp;	&emsp;let tmp = inputArr[i];<br>
                            	&emsp;	&emsp;	&emsp;inputArr[i] = inputArr[min];<br>
                            	&emsp;	&emsp;	&emsp;inputArr[min] = tmp;<br>
                                &emsp;&emsp;&emsp;}<br>
                                &emsp;&emsp;}<br>
                                &emsp;return inputArr;<br>
                            }<br>
          </p>
        </div>
    </div>










    <div class="shead" id="BubleS">

        <h1 class="title">Пузырьковая Сортировка</h1>

        <span class="dis">
            Также является одной из простых сортировок.
            Принцип действий прост: обходим массив от начала до конца, попутно меняя местами неотсортированные соседние элементы. В результате первого прохода на последнее место «всплывёт» максимальный элемент. Теперь снова обходим неотсортированную часть массива (от первого элемента до предпоследнего) и меняем по пути неотсортированных соседей. Второй по величине элемент окажется на предпоследнем месте. 
            Продолжая в том же духе, будем обходить всё уменьшающуюся неотсортированную часть массива, запихивая найденные максимумы в конец.
        </span>
            
        <canvas id="BubleChart"></canvas>
        <form class="buttons">
            <input type="text" class="Count" id="Bubbleco" value="0" width="150" disabled>
            <input type="button" class="Brand" value="Перемешать" width="150" onclick="ShuffleB()">
            <input type="button" class="Iter" value="Шаг" width="150" onclick="SortBO()">
            <input type="button" class="Sort" value="Сортировать" width="150" onclick="SortB()">
        </form>

        <button class="accordion">Код</button>
        <div class="panel">
          <p>
            function bubbleSort(arr){<br>
                &emsp;for (var i = 0, endI = arr.length - 1; i < endI; i++) {<br>
                    &emsp;&emsp;for (var j = 0, endJ = endI - i; j < endJ; j++) {<br>
                        &emsp;&emsp;&emsp;if (arr[j] > arr[j + 1]) {<br>
                            &emsp;&emsp;&emsp;&emsp;var swap = arr[j];<br>
                            &emsp;&emsp;&emsp;&emsp;arr[j] = arr[j + 1];<br>
                            &emsp;&emsp;&emsp;&emsp;arr[j + 1] = swap;<br>
                            &emsp;&emsp;&emsp;}<br>
                            &emsp;&emsp;}<br>
                            &emsp;}<br>
                            &emsp;return arr;<br>
            }<br>
          </p>
        </div>
    </div>






    <div class="shead" id="InsertS">

        <h1 class="title">Сортировка вставками</h1>

        <span class="dis">
            Сортировка вставками (Insertion Sort) — это простой алгоритм сортировки. Суть его заключается в том что, на каждом шаге алгоритма мы берем один из элементов массива, находим позицию для вставки и вставляем. Стоит отметить что массив из 1-го элемента считается отсортированным.
        </span>
            
        <canvas id="InsertChart"></canvas>
        <form class="buttons">
            <input type="text" class="Count" id="Insrtco" value="0" width="150" disabled>
            <input type="button" class="Brand" value="Перемешать" width="150" onclick="ShuffleINS()">
            <input type="button" class="Iter" value="Шаг" width="150" onclick="SortINS()">
            <input type="button" class="Sort" value="Сортировать" width="150" onclick="SortI()">
        </form>
        <button class="accordion">Код</button>
        <div class="panel">
          <p>
            function insertionSort(inpArr) {<br>
                &emsp;let n = inpArr.length;<br>
                &emsp;for (let i = 1; i < n; i++) {<br>
                    &emsp;&emsp;let current = inpArr[i];<br>
                    &emsp;&emsp;let j = i-1;<br>
                    &emsp;&emsp;while ((j > -1) && (current < inpArr[j])) {<br>
                        &emsp;&emsp;&emsp;inpArr[j+1] = inpArr[j];<br>
                        &emsp;&emsp;&emsp;j--;<br>
                        &emsp;&emsp;}<br>
                        &emsp;&emsp;inpArr[j+1] = current;<br>
                        &emsp;}<br>
                    &emsp;return inpArr;<br>
            }<br>
          </p>
        </div>
    </div>

    <div class="shead" id="ShellS">

        <h1 class="title">Сортировка Шелла</h1>

        <span class="dis">
            Этот метод разработал Дональд Л. Шелл (Donald L. Shell) в 1959 году. Он основан на сортировке методом вставок и при первом рассмотрении может показаться несколько странным.
            Сортировка методом Шелла (Shell sort) пытается повысить скорость работы за счет более быстрого перемещения элементов, находящихся далеко от нужных им позиций. Она предполагает перемещение таких элементов большими "прыжками" через несколько элементов одновременно, уменьшая размер "прыжков" и, в конце концов, окончательная установка элементов в нужные позиции выполняется с помощью классической сортировки методом вставок.
        </span>
            
        <canvas id="ShellChart"></canvas>
        <form class="buttons">
            <input type="text" class="Count" id="Shellco" value="0" width="150" disabled>
            <input type="button" class="Brand" value="Перемешать" width="150" onclick="ShuffleShell()">
            <input type="button" class="Iter" value="Шаг" width="150" onclick="SortShell()">
            <input type="button" class="Sort" value="Сортировать" width="150" onclick="SortShe()">
        </form>

        <button class="accordion">Код</button>
        <div class="panel">
          <p>
            function ShellSort(inputarr) {<br>
            &emsp;let n = inputarr.length;<br>
            &emsp;for(let i = 0; i < n; i++) {<br>
                &emsp;&emsp;let min = i;<br>
                &emsp;&emsp;for(let j = i; j < n; j++) {<br>
                    &emsp;&emsp;&emsp;if(inputarr[j] < inputarr[min]) {<br>
                        &emsp;&emsp;&emsp;&emsp;min=j;<br>
                        &emsp;&emsp;&emsp;}<br>
                        &emsp;&emsp;}<br>
                        &emsp;if (min != i) {<br>
                            &emsp;&emsp;let tmp = inputarr[i];<br>
                            &emsp;&emsp;inputarr[i] = inputarr[min];<br>
                            &emsp;&emsp;inputarr[min] = tmp;<br>
                    &emsp;&emsp;}<br>
                    &emsp;}<br>
                    &emsp;return inputarr;<br>
            }<br>
          </p>
        </div>
    </div>

    <div class="shead" id="MergeS">

        <h1 class="title">Cортировка слиянием</h1>

        <span class="dis">
             Массив рекурсивно разбивается пополам, и каждая из половин делиться до тех пор, пока размер очередного подмассива не станет равным единице. Далее выполняется операция алгоритма, называемая слиянием. Два единичных массива сливаются в общий результирующий массив, при этом из каждого выбирается меньший элемент (сортировка по возрастанию) и записывается в свободную левую ячейку результирующего массива. После чего из двух результирующих массивов собирается третий общий отсортированный массив, и так далее. В случае если один из массивов закончиться, элементы другого дописываются в собираемый массив.В конце операции слияния, элементы перезаписываются из результирующего массива в исходный.
        </span>
            
        <canvas id="MergeChart"></canvas>
        <form class="buttons">
            <input type="text" class="Count" id="Mergeco" value="0" width="150" disabled>
            <input type="button" class="Brand" value="Перемешать" width="150" onclick="ShuffleMerge()">
            <input type="button" class="Sort" value="Сортировать" width="150" onclick="SortME()">
        </form>

        <button class="accordion">Код</button>
            <div class="panel">
              <p>
        function MergeSort(array) {<br>
            &emsp;if (array.length>1){<br>
                &emsp;&emsp;let mid = Math.floor(array.length/2)<br>
                &emsp;&emsp;lefthalf = array.slice(0,mid)<br>
                &emsp;&emsp;righthalf = array.slice(mid);<br>
                &emsp;&emsp;MergeSort(lefthalf)<br>
                &emsp;&emsp;MergeSort(righthalf)<br>
                &emsp;&emsp;let i = j = k = 0<br>
                &emsp;&emsp;while (i<lefthalf.length && j < righthalf.length ){ <br>
                &emsp;&emsp;&emsp;if (lefthalf[i] < righthalf[j]){<br>
                    &emsp;&emsp;&emsp;array[k]=lefthalf[i]<br>
                    &emsp;&emsp;&emsp;i++;<br>
                    &emsp;&emsp;&emsp;}<br>
                    &emsp;else{<br>
                        &emsp;&emsp;array[k]=righthalf[j]<br>
                        &emsp;&emsp;j++<br>
                        &emsp;&emsp;}<br>
                        &emsp;k++<br>
                        &emsp;}<br>
                    &emsp;&emsp;while (i < lefthalf.length){<br>
                        &emsp;&emsp;&emsp;array[k]=lefthalf[i]<br>
                        &emsp;&emsp;&emsp;i++<br>
                        &emsp;&emsp;&emsp;k++<br>
                        &emsp;&emsp;&emsp;}<br>
                        &emsp;&emsp;while( j< righthalf.length){<br>
                        &emsp;&emsp;&emsp;array[k]=righthalf[j]<br>
                        &emsp;&emsp;&emsp;j++<br>
                        &emsp;&emsp;&emsp;k++<br>
                        &emsp;&emsp;&emsp;}<br>
                        &emsp;&emsp;}<br>
                        &emsp;return array<br>
                }<br>
              </p>
            </div>
    </div>


    <div class="shead" id="CounS">

        <h1 class="title">Cортировка подсчетом Убрать ?</h1>

        <span class="dis">
             Сортировка подсчётом — алгоритм сортировки, в котором используется диапазон чисел сортируемого массива (списка) для подсчёта совпадающих элементов. Применение сортировки подсчётом целесообразно лишь тогда, когда сортируемые числа имеют (или их можно отобразить в) диапазон возможных значений, который достаточно мал по сравнению с сортируемым множеством, например, миллион натуральных чисел меньших 1000.

            Эта сортировка используется, когда на вход подается массив структур данных, который следует отсортировать по ключам (key). Нужно создать вспомогательный массив, каждый элемент вспомогательного массива в дальнейшем будет содержать список элементов из входного массива. Затем последовательно прочитать элементы входного массива, каждый элемент этого массива добавить в список. В заключении пройти по массиву C, для каждого элемента в входного массива последовательно записывать элементы списка.

        </span>
            
        <canvas id="CountingChart"></canvas>
        <form class="buttons">
            <input type="text" class="Count" id="Counteco" value="0" width="150" disabled>
            <input type="button" class="Brand" value="Перемешать" width="150" onclick="ShuffleCounte()">
            <input type="button" class="Iter" value="Шаг" width="150" onclick="SortCounte()">
            <input type="button" class="Sort" value="Сортировать" width="150" onclick="SortCO()">
        </form>

        <button class="accordion">Код</button>
        <div class="panel">
          <p>
            function CountingSort(A) {<br>
                &emsp;var n = A.length, Count = [], B = [];<br>
                &emsp;for (var i = 0; i < n; i++) Count[ i ] = 0;<br>
                &emsp;for (var i = 0; i < n-1; i++){<br>
                    &emsp;&emsp;for (var j = i+1; j < n; j++){<br>
                        &emsp;&emsp;&emsp;if (A[ i ] < A[j]) Count[j]++;<br>
                        &emsp;&emsp;&emsp;else Count[ i ]++;<br>
                        &emsp;&emsp;}<br>
                        &emsp;}<br>
                        &emsp;for (var i = 0; i < n; i++) B[Count[ i ]] = A[ i ];<br>
                    &emsp;return B;<br>
            }<br>
          </p>
        </div>
    </div>
    <footer>
        © ППШ. Все права защищены. <a href="https://github.com/chif45/sortings-methods">GitHub</a>. <a href="./Dvavago.html">DvaVaGo</a>
    </footer>
    <script>
        var acc = document.getElementsByClassName("accordion");
        var acci;
        for (acci = 0; acci < acc.length; acci++) {
          acc[acci].addEventListener("click", function() {
            this.classList.toggle("active");
            var panel = this.nextElementSibling;
            if (panel.style.display === "block") {
              panel.style.display = "none";
            } else {
              panel.style.display = "block";
            }
          });
        }
        </script>
</body>
</html>